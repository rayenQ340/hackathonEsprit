{"version":3,"file":"NodeClient.js","sources":["../../src/client/NodeClient.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport fs from \"fs\";\nimport util from \"util\";\nimport Client from \"./Client.js\";\nimport NodeChannel from \"../channel/NodeChannel.js\";\nimport NodeMirrorChannel from \"../channel/NodeMirrorChannel.js\";\nimport LedgerId from \"../LedgerId.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport NodeAddressBook from \"../address_book/NodeAddressBook.js\";\nimport * as mainnet from \"./addressbooks/mainnet.js\";\nimport * as testnet from \"./addressbooks/testnet.js\";\nimport * as previewnet from \"./addressbooks/previewnet.js\";\nimport * as hex from \"../encoding/hex.js\";\nimport AddressBookQuery from \"../network/AddressBookQuery.js\";\nimport FileId from \"../file/FileId.js\";\n\nconst readFileAsync = util.promisify(fs.readFile);\n\n/**\n * @typedef {import(\"./Client.js\").ClientConfiguration} ClientConfiguration\n */\n\nexport const Network = {\n    LOCAL_NODE: {\n        \"127.0.0.1:50211\": new AccountId(3),\n    },\n};\n\nexport const MirrorNetwork = {\n    /**\n     * @param {string} name\n     * @returns {string[]}\n     */\n    fromName(name) {\n        switch (name) {\n            case \"mainnet\":\n                return MirrorNetwork.MAINNET;\n\n            case \"testnet\":\n                return MirrorNetwork.TESTNET;\n\n            case \"previewnet\":\n                return MirrorNetwork.PREVIEWNET;\n\n            case \"local-node\":\n                return MirrorNetwork.LOCAL_NODE;\n\n            default:\n                throw new Error(`unknown network name: ${name}`);\n        }\n    },\n\n    MAINNET: [\"mainnet-public.mirrornode.hedera.com:443\"],\n    TESTNET: [\"testnet.mirrornode.hedera.com:443\"],\n    PREVIEWNET: [\"previewnet.mirrornode.hedera.com:443\"],\n    LOCAL_NODE: [\"127.0.0.1:5600\"],\n};\n\n/**\n * @augments {Client<NodeChannel, NodeMirrorChannel>}\n * Client for interacting with the Hedera network using Node.js.\n * Extends the base Client class with Node.js specific implementations.\n */\nexport default class NodeClient extends Client {\n    /**\n     * @param {ClientConfiguration} [props]\n     */\n    constructor(props) {\n        super(props);\n\n        /** @private */\n        this._maxExecutionTime = 10000;\n\n        if (props != null) {\n            if (typeof props.network === \"string\") {\n                this._setNetworkFromName(props.network);\n            } else if (props.network != null) {\n                this.setNetwork(props.network);\n            }\n\n            if (typeof props.mirrorNetwork === \"string\") {\n                switch (props.mirrorNetwork) {\n                    case \"mainnet\":\n                        this.setMirrorNetwork(MirrorNetwork.MAINNET);\n                        break;\n\n                    case \"testnet\":\n                        this.setMirrorNetwork(MirrorNetwork.TESTNET);\n                        break;\n\n                    case \"previewnet\":\n                        this.setMirrorNetwork(MirrorNetwork.PREVIEWNET);\n                        break;\n\n                    default:\n                        this.setMirrorNetwork([props.mirrorNetwork]);\n                        break;\n                }\n            } else if (props.mirrorNetwork != null) {\n                this.setMirrorNetwork(props.mirrorNetwork);\n            }\n        }\n    }\n\n    /**\n     * @param {string | ClientConfiguration} data\n     * @returns {NodeClient}\n     */\n    static fromConfig(data) {\n        return new NodeClient(\n            typeof data === \"string\"\n                ? /** @type {ClientConfiguration | undefined} */ (\n                      JSON.parse(data)\n                  )\n                : data,\n        );\n    }\n\n    /**\n     * @param {string} filename\n     * @returns {Promise<NodeClient>}\n     */\n    static async fromConfigFile(filename) {\n        return NodeClient.fromConfig(await readFileAsync(filename, \"utf8\"));\n    }\n\n    /**\n     * Construct a client for a specific network.\n     *\n     * It is the responsibility of the caller to ensure that all nodes in the map are part of the\n     * same Hedera network. Failure to do so will result in undefined behavior.\n     *\n     * The client will load balance all requests to Hedera using a simple round-robin scheme to\n     * chose nodes to send transactions to. For one transaction, at most 1/3 of the nodes will be\n     * tried.\n     *\n     * @param {{[key: string]: (string | AccountId)}} network\n     * @param {ClientConfiguration} [props]\n     * @returns {NodeClient}\n     */\n    static forNetwork(network, props) {\n        return new NodeClient({ network, ...props });\n    }\n\n    /**\n     * @param {string} network\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {NodeClient}\n     */\n    static forName(network, props = {}) {\n        return new NodeClient({ network, ...props });\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for Mainnet access.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {NodeClient}\n     */\n    static forMainnet(props = {}) {\n        return new NodeClient({ network: \"mainnet\", ...props });\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for Testnet access.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {NodeClient}\n     */\n    static forTestnet(props = {}) {\n        return new NodeClient({ network: \"testnet\", ...props });\n    }\n\n    /**\n     * @param {string[] | string} mirrorNetwork\n     * @returns {Promise<NodeClient>}\n     */\n    static async forMirrorNetwork(mirrorNetwork) {\n        const client = new NodeClient();\n\n        client.setMirrorNetwork(mirrorNetwork).setNetworkUpdatePeriod(10000);\n\n        // Execute an address book query to get the network nodes\n        const addressBook = await new AddressBookQuery()\n            .setFileId(FileId.ADDRESS_BOOK)\n            .execute(client);\n\n        client.setNetworkFromAddressBook(addressBook);\n\n        return client;\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for Previewnet access.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {NodeClient}\n     */\n    static forPreviewnet(props = {}) {\n        return new NodeClient({ network: \"previewnet\", ...props });\n    }\n\n    /**\n     * Construct a Hedera client pre-configured for local-node access.\n     *\n     * @param {object} [props]\n     * @param {boolean} [props.scheduleNetworkUpdate]\n     * @returns {NodeClient}\n     */\n    static forLocalNode(props = { scheduleNetworkUpdate: false }) {\n        return new NodeClient({ network: \"local-node\", ...props });\n    }\n\n    /**\n     * @param {{[key: string]: (string | AccountId)} | string} network\n     * @returns {void}\n     */\n    setNetwork(network) {\n        if (typeof network === \"string\") {\n            this._setNetworkFromName(network);\n        } else {\n            this._network.setNetwork(network);\n        }\n    }\n\n    /**\n     * Available only for NodeClient\n     *\n     * @param {number} maxExecutionTime\n     * @returns {this}\n     */\n    setMaxExecutionTime(maxExecutionTime) {\n        this._maxExecutionTime = maxExecutionTime;\n        return this;\n    }\n\n    /**\n     * @private\n     * @param {string} name\n     * @returns {this}\n     */\n    _setNetworkFromName(name) {\n        switch (name) {\n            case \"mainnet\":\n                this.setNetworkFromAddressBook(\n                    NodeAddressBook.fromBytes(hex.decode(mainnet.addressBook)),\n                );\n                this.setMirrorNetwork(MirrorNetwork.MAINNET);\n                this.setLedgerId(LedgerId.MAINNET);\n                break;\n\n            case \"testnet\":\n                this.setNetworkFromAddressBook(\n                    NodeAddressBook.fromBytes(hex.decode(testnet.addressBook)),\n                );\n                this.setMirrorNetwork(MirrorNetwork.TESTNET);\n                this.setLedgerId(LedgerId.TESTNET);\n                break;\n\n            case \"previewnet\":\n                this.setNetworkFromAddressBook(\n                    NodeAddressBook.fromBytes(\n                        hex.decode(previewnet.addressBook),\n                    ),\n                );\n                this.setMirrorNetwork(MirrorNetwork.PREVIEWNET);\n                this.setLedgerId(LedgerId.PREVIEWNET);\n                break;\n\n            case \"local-node\":\n                this.setNetwork(Network.LOCAL_NODE);\n                this.setMirrorNetwork(MirrorNetwork.LOCAL_NODE);\n                this.setLedgerId(LedgerId.LOCAL_NODE);\n                break;\n\n            default:\n                throw new Error(\n                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                    `unknown network: ${name}`,\n                );\n        }\n        return this;\n    }\n\n    /**\n     * @param {string[] | string} mirrorNetwork\n     * @returns {this}\n     */\n    setMirrorNetwork(mirrorNetwork) {\n        if (typeof mirrorNetwork === \"string\") {\n            switch (mirrorNetwork) {\n                case \"local-node\":\n                    this._mirrorNetwork.setNetwork(MirrorNetwork.LOCAL_NODE);\n                    break;\n                case \"previewnet\":\n                    this._mirrorNetwork.setNetwork(MirrorNetwork.PREVIEWNET);\n                    break;\n                case \"testnet\":\n                    this._mirrorNetwork.setNetwork(MirrorNetwork.TESTNET);\n                    break;\n                case \"mainnet\":\n                    this._mirrorNetwork.setNetwork(MirrorNetwork.MAINNET);\n                    break;\n                default:\n                    this._mirrorNetwork.setNetwork([mirrorNetwork]);\n            }\n        } else {\n            this._mirrorNetwork.setNetwork(mirrorNetwork);\n        }\n\n        return this;\n    }\n\n    /**\n     * @override\n     * @returns {(address: string, cert?: string) => NodeChannel}\n     */\n    _createNetworkChannel() {\n        return (address) => new NodeChannel(address, this._maxExecutionTime);\n    }\n\n    /**\n     * @override\n     * @returns {(address: string) => NodeMirrorChannel}\n     */\n    _createMirrorNetworkChannel() {\n        return (address) => new NodeMirrorChannel(address);\n    }\n}\n"],"names":["readFileAsync","util","promisify","fs","readFile","Network","LOCAL_NODE","AccountId","MirrorNetwork","MAINNET","TESTNET","PREVIEWNET","NodeClient","Client","constructor","props","super","this","_maxExecutionTime","network","_setNetworkFromName","setNetwork","mirrorNetwork","setMirrorNetwork","fromConfig","data","JSON","parse","fromConfigFile","filename","forNetwork","forName","forMainnet","forTestnet","forMirrorNetwork","client","setNetworkUpdatePeriod","addressBook","AddressBookQuery","setFileId","FileId","ADDRESS_BOOK","execute","setNetworkFromAddressBook","forPreviewnet","forLocalNode","scheduleNetworkUpdate","_network","setMaxExecutionTime","maxExecutionTime","name","NodeAddressBook","fromBytes","hex.decode","mainnet.addressBook","setLedgerId","LedgerId","testnet.addressBook","previewnet.addressBook","Error","_mirrorNetwork","_createNetworkChannel","address","NodeChannel","_createMirrorNetworkChannel","NodeMirrorChannel"],"mappings":"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"}