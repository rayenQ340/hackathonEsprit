{"version":3,"file":"AccountId.js","sources":["../../src/account/AccountId.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport Long from \"long\";\nimport * as entity_id from \"../EntityIdHelper.js\";\nimport * as HieroProto from \"@hashgraph/proto\";\nimport Key from \"../Key.js\";\nimport PublicKey from \"../PublicKey.js\";\nimport CACHE from \"../Cache.js\";\nimport EvmAddress from \"../EvmAddress.js\";\nimport * as hex from \".././encoding/hex.js\";\nimport { isLongZeroAddress } from \"../util.js\";\n\n/**\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n */\n\n/**\n * The ID for a crypto-currency account on Hedera.\n */\nexport default class AccountId {\n    /**\n     * @param {number | Long | import(\"../EntityIdHelper\").IEntityId} props\n     * @param {(number | Long)=} realm\n     * @param {(number | Long)=} num\n     * @param {(PublicKey)=} aliasKey\n     * @param {(EvmAddress)=} evmAddress\n     */\n    constructor(props, realm, num, aliasKey, evmAddress) {\n        const result = entity_id.constructor(props, realm, num);\n\n        this.shard = result.shard;\n        this.realm = result.realm;\n        this.num = result.num;\n        this.aliasKey = aliasKey != null ? aliasKey : null;\n        this.evmAddress = evmAddress != null ? evmAddress : null;\n\n        /**\n         * @type {string | null}\n         */\n        this._checksum = null;\n    }\n\n    /**\n     * @description Accepts the following formats as string:\n     *      - as stand alone nubmers\n     *      - as shard.realm.num\n     *      - as shard.realm.hex (wo 0x prefix)\n     *      - hex (w/wo 0x prefix)\n     * @param {string} text\n     * @returns {AccountId}\n     */\n    static fromString(text) {\n        let shard = Long.ZERO;\n        let realm = Long.ZERO;\n        let num = Long.ZERO;\n        let aliasKey = undefined;\n        let evmAddress = undefined;\n\n        if ((text.startsWith(\"0x\") && text.length == 42) || text.length == 40) {\n            evmAddress = EvmAddress.fromString(text);\n        } else {\n            const result = entity_id.fromStringSplitter(text);\n\n            if (Number.isNaN(result.shard) || Number.isNaN(result.realm)) {\n                throw new Error(\"invalid format for entity ID\");\n            }\n\n            if (result.shard != null) shard = Long.fromString(result.shard);\n            if (result.realm != null) realm = Long.fromString(result.realm);\n\n            if (result.numOrHex.length < 20) {\n                num = Long.fromString(result.numOrHex);\n            } else if (result.numOrHex.length == 40) {\n                evmAddress = EvmAddress.fromString(result.numOrHex);\n            } else {\n                aliasKey = PublicKey.fromString(result.numOrHex);\n            }\n        }\n\n        return new AccountId(shard, realm, num, aliasKey, evmAddress);\n    }\n\n    /**\n     * @description This handles both long-zero format and evm address format addresses.\n     * If an actual evm address is passed, please use `AccountId.populateAccountNum(client)` method\n     * to get the actual `num` value, since there is no cryptographic relation to the evm address\n     * and cannot be populated directly\n     * @param {Long | number} shard\n     * @param {Long | number} realm\n     * @param {EvmAddress | string} evmAddress\n     * @returns {AccountId}\n     */\n    static fromEvmAddress(shard, realm, evmAddress) {\n        const evmAddressObj =\n            typeof evmAddress === \"string\"\n                ? EvmAddress.fromString(evmAddress)\n                : evmAddress;\n\n        if (isLongZeroAddress(evmAddressObj.toBytes())) {\n            return new AccountId(\n                ...entity_id.fromSolidityAddress(evmAddressObj.toString()),\n            );\n        } else {\n            return new AccountId(shard, realm, 0, undefined, evmAddressObj);\n        }\n    }\n\n    /**\n     * @deprecated - Use `fromEvmAddress` instead\n     * @summary Accepts an evm address only as `EvmAddress` type\n     * @param {EvmAddress} evmAddress\n     * @returns {AccountId}\n     */\n    static fromEvmPublicAddress(evmAddress) {\n        return new AccountId(0, 0, 0, undefined, evmAddress);\n    }\n\n    /**\n     * @internal\n     * @param {HieroProto.proto.IAccountID} id\n     * @returns {AccountId}\n     */\n    static _fromProtobuf(id) {\n        let aliasKey = undefined;\n        let evmAddress = undefined;\n\n        if (id.alias != null) {\n            if (id.alias.length === 20) {\n                evmAddress = EvmAddress.fromBytes(id.alias);\n            } else {\n                aliasKey = Key._fromProtobufKey(\n                    HieroProto.proto.Key.decode(id.alias),\n                );\n            }\n        }\n\n        if (!(aliasKey instanceof PublicKey)) {\n            aliasKey = undefined;\n        }\n\n        return new AccountId(\n            id.shardNum != null ? id.shardNum : 0,\n            id.realmNum != null ? id.realmNum : 0,\n            id.accountNum != null ? id.accountNum : 0,\n            aliasKey,\n            evmAddress,\n        );\n    }\n\n    /**\n     * @returns {string | null}\n     */\n    get checksum() {\n        return this._checksum;\n    }\n\n    /**\n     * @returns {?EvmAddress}\n     */\n    getEvmAddress() {\n        return this.evmAddress;\n    }\n\n    /**\n     * @description Gets the actual `num` field of the `AccountId` from the Mirror Node.\n     * Should be used after generating `AccountId.fromEvmAddress()` because it sets the `num` field to `0`\n     * automatically since there is no connection between the `num` and the `evmAddress`\n     * @param {Client} client\n     * @returns {Promise<AccountId>}\n     */\n    async populateAccountNum(client) {\n        if (this.evmAddress === null) {\n            throw new Error(\"field `evmAddress` should not be null\");\n        }\n        const mirrorUrl = client.mirrorNetwork[0].slice(\n            0,\n            client.mirrorNetwork[0].indexOf(\":\"),\n        );\n\n        await new Promise((resolve) => {\n            setTimeout(resolve, 3000);\n        });\n\n        /* eslint-disable */\n        const url = `https://${mirrorUrl}/api/v1/accounts/${this.evmAddress.toString()}`;\n        const response = await fetch(url);\n        const data = await response.json();\n        const mirrorAccountId = data.account;\n\n        this.num = Long.fromString(\n            mirrorAccountId.slice(mirrorAccountId.lastIndexOf(\".\") + 1),\n        );\n        /* eslint-enable */\n\n        return this;\n    }\n\n    /**\n     * @description Populates `evmAddress` field of the `AccountId` extracted from the Mirror Node.\n     * @param {Client} client\n     * @returns {Promise<AccountId>}\n     */\n    async populateAccountEvmAddress(client) {\n        if (this.num === null) {\n            throw new Error(\"field `num` should not be null\");\n        }\n        const mirrorUrl = client.mirrorNetwork[0].slice(\n            0,\n            client.mirrorNetwork[0].indexOf(\":\"),\n        );\n\n        await new Promise((resolve) => {\n            setTimeout(resolve, 3000);\n        });\n\n        /* eslint-disable */\n        const url = `https://${mirrorUrl}/api/v1/accounts/${this.num.toString()}`;\n        const response = await fetch(url);\n        const data = await response.json();\n        const mirrorAccountId = data.evm_address;\n\n        this.evmAddress = EvmAddress.fromString(mirrorAccountId);\n        /* eslint-enable */\n\n        return this;\n    }\n\n    /**\n     * @deprecated - Use `validateChecksum` instead\n     * @param {Client} client\n     */\n    validate(client) {\n        console.warn(\"Deprecated: Use `validateChecksum` instead\");\n        this.validateChecksum(client);\n    }\n\n    /**\n     * @param {Client} client\n     */\n    validateChecksum(client) {\n        if (this.aliasKey != null) {\n            throw new Error(\n                \"cannot calculate checksum with an account ID that has a aliasKey\",\n            );\n        }\n\n        entity_id.validateChecksum(\n            this.shard,\n            this.realm,\n            this.num,\n            this._checksum,\n            client,\n        );\n    }\n\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {AccountId}\n     */\n    static fromBytes(bytes) {\n        return AccountId._fromProtobuf(\n            HieroProto.proto.AccountID.decode(bytes),\n        );\n    }\n\n    /**\n     * @deprecated - Use `fromEvmAddress` instead\n     * @param {string} address\n     * @returns {AccountId}\n     */\n    static fromSolidityAddress(address) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        if (isLongZeroAddress(hex.decode(address))) {\n            return new AccountId(...entity_id.fromSolidityAddress(address));\n        } else {\n            return this.fromEvmAddress(0, 0, address);\n        }\n    }\n\n    /**\n     * @description Statically compute the EVM address. Use only with non-native EVM accounts.\n     * If the account is EVM-native, the EVM address depends on the public key and is not directly related to the account ID.\n     * @returns {string}\n     */\n    toSolidityAddress() {\n        if (this.evmAddress != null) {\n            return this.evmAddress.toString();\n        } else if (\n            this.aliasKey != null &&\n            this.aliasKey._key._type == \"secp256k1\"\n        ) {\n            return this.aliasKey.toEvmAddress();\n        } else {\n            return entity_id.toSolidityAddress([\n                this.shard,\n                this.realm,\n                this.num,\n            ]);\n        }\n    }\n\n    //TODO remove the comments after we get to HIP-631\n    /**\n     * @internal\n     * @returns {HieroProto.proto.IAccountID}\n     */\n    _toProtobuf() {\n        let alias = null;\n        //let evmAddress = null;\n\n        if (this.aliasKey != null) {\n            alias = HieroProto.proto.Key.encode(\n                this.aliasKey._toProtobufKey(),\n            ).finish();\n        } else if (this.evmAddress != null) {\n            alias = this.evmAddress._bytes;\n        }\n\n        /* if (this.evmAddress != null) {\n            evmAddress = this.evmAddress._bytes;\n        } */\n\n        const isHollowAccount = this.num.eq(Long.fromBigInt(0n)) && alias;\n\n        if (alias) {\n            return {\n                alias: isHollowAccount ? alias : null,\n                accountNum: isHollowAccount ? null : this.num,\n                shardNum: this.shard,\n                realmNum: this.realm,\n            };\n        }\n        return {\n            alias: null,\n            accountNum: this.num,\n            shardNum: this.shard,\n            realmNum: this.realm,\n        };\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return HieroProto.proto.AccountID.encode(this._toProtobuf()).finish();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let account = this.num.toString();\n\n        if (this.aliasKey != null) {\n            account = this.aliasKey.toString();\n        } else if (this.evmAddress != null) {\n            account = this.evmAddress.toString();\n        }\n\n        return `${this.shard.toString()}.${this.realm.toString()}.${account}`;\n    }\n\n    /**\n     * @param {Client} client\n     * @returns {string}\n     */\n    toStringWithChecksum(client) {\n        if (this.aliasKey != null) {\n            throw new Error(\n                \"cannot calculate checksum with an account ID that has a aliasKey\",\n            );\n        }\n\n        return entity_id.toStringWithChecksum(this.toString(), client);\n    }\n\n    /**\n     * @param {this} other\n     * @returns {boolean}\n     */\n    equals(other) {\n        let account = false;\n\n        if (this.aliasKey != null && other.aliasKey != null) {\n            account = this.aliasKey.equals(other.aliasKey);\n        } else if (this.evmAddress != null && other.evmAddress != null) {\n            account = this.evmAddress.equals(other.evmAddress);\n        } else if (\n            this.aliasKey == null &&\n            other.aliasKey == null &&\n            this.evmAddress == null &&\n            other.evmAddress == null\n        ) {\n            account = this.num.eq(other.num);\n        }\n\n        return (\n            this.shard.eq(other.shard) && this.realm.eq(other.realm) && account\n        );\n    }\n\n    /**\n     * @returns {AccountId}\n     */\n    clone() {\n        const id = new AccountId(this);\n        id._checksum = this._checksum;\n        id.aliasKey = this.aliasKey;\n        id.evmAddress = this.evmAddress;\n        return id;\n    }\n\n    /**\n     * @param {AccountId} other\n     * @returns {number}\n     */\n    compare(other) {\n        let comparison = this.shard.compare(other.shard);\n        if (comparison != 0) {\n            return comparison;\n        }\n\n        comparison = this.realm.compare(other.realm);\n        if (comparison != 0) {\n            return comparison;\n        }\n\n        if (this.aliasKey != null && other.aliasKey != null) {\n            const t = this.aliasKey.toString();\n            const o = other.aliasKey.toString();\n\n            if (t > o) {\n                return 1;\n            } else if (t < o) {\n                return -1;\n            } else {\n                return 0;\n            }\n        } else if (this.evmAddress != null && other.evmAddress != null) {\n            const t = this.evmAddress.toString();\n            const o = other.evmAddress.toString();\n\n            if (t > o) {\n                return 1;\n            } else if (t < o) {\n                return -1;\n            } else {\n                return 0;\n            }\n        } else if (\n            this.aliasKey == null &&\n            other.aliasKey == null &&\n            this.evmAddress == null &&\n            other.evmAddress == null\n        ) {\n            return this.num.compare(other.num);\n        } else {\n            return 1;\n        }\n    }\n}\n\nCACHE.setAccountIdConstructor(\n    (shard, realm, key) => new AccountId(shard, realm, Long.ZERO, key),\n);\n"],"names":["AccountId","constructor","props","realm","num","aliasKey","evmAddress","result","entity_id.constructor","this","shard","_checksum","fromString","text","Long","ZERO","startsWith","length","EvmAddress","entity_id.fromStringSplitter","Number","isNaN","Error","numOrHex","PublicKey","fromEvmAddress","evmAddressObj","isLongZeroAddress","toBytes","entity_id.fromSolidityAddress","toString","undefined","fromEvmPublicAddress","_fromProtobuf","id","alias","fromBytes","Key","_fromProtobufKey","HieroProto","proto","decode","shardNum","realmNum","accountNum","checksum","getEvmAddress","populateAccountNum","client","mirrorUrl","mirrorNetwork","slice","indexOf","Promise","resolve","setTimeout","url","response","fetch","mirrorAccountId","json","account","lastIndexOf","populateAccountEvmAddress","evm_address","validate","console","warn","validateChecksum","entity_id.validateChecksum","bytes","AccountID","fromSolidityAddress","address","hex.decode","toSolidityAddress","_key","_type","toEvmAddress","entity_id.toSolidityAddress","_toProtobuf","encode","_toProtobufKey","finish","_bytes","isHollowAccount","eq","fromBigInt","toStringWithChecksum","entity_id.toStringWithChecksum","equals","other","clone","compare","comparison","t","o","CACHE","setAccountIdConstructor","key"],"mappings":"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"}